---

title: Algoritma Dijkstra
date: 2025-06-3
categories: \[desain dan analisis algoritma]
tags: \[belajar]     # TAG names should always be lowercase
description: Apa itu Algoritma Dijkstra?
----------------------------------------

### Apa itu Algoritma Dijkstra?

Algoritma Dijkstra adalah algoritma klasik yang banyak digunakan untuk menemukan **jalur terpendek** antara simpul sumber dan semua simpul lainnya dalam graf berbobot. Dikembangkan oleh ilmuwan komputer Edsger W. Dijkstra pada tahun 1956, tujuan utamanya adalah untuk menavigasi jaringan titik, di mana setiap koneksi (atau sisi) memiliki "biaya" atau "berat" tertentu yang terkait dengannya. Berbeda dengan algoritma yang lebih sederhana seperti Pencarian Lebar Pertama (BFS) yang hanya menemukan jalur terpendek berdasarkan jumlah sisi, Dijkstra memperhitungkan total berat jalur, menjadikannya ideal untuk skenario yang lebih realistis seperti menemukan rute tercepat dalam jaringan jalan.

### Ide Utama: Pendekatan Greedy

Inti dari Algoritma Dijkstra adalah menggunakan **pendekatan greedy**. Ini berarti bahwa pada setiap langkah, algoritma selalu membuat pilihan yang tampaknya terbaik pada saat itu. Algoritma ini mempertahankan himpunan simpul yang sudah dikunjungi, dan untuk setiap simpul yang belum dikunjungi, ia melacak jarak terpendek yang ditemukan sejauh ini dari sumber. Algoritma secara greedy memilih simpul yang belum dikunjungi dengan jarak terkecil yang diketahui, menandainya sebagai telah dikunjungi, dan kemudian memeriksa semua tetangganya untuk melihat apakah jalur yang lebih pendek dapat ditemukan melalui simpul yang baru dikunjungi ini.

### Cara Kerja: Komponen Kunci

Untuk mengimplementasikan strateginya, algoritma menggunakan beberapa struktur data kunci:

* **Peta jarak** (atau array) untuk menyimpan jarak terpendek dari sumber ke setiap simpul lainnya. Ini diinisialisasi ke tak terhingga untuk semua simpul kecuali sumber, yang diinisialisasi dengan nilai 0.
* **Himpunan simpul yang sudah dikunjungi** untuk melacak simpul yang jarak terpendeknya sudah final.
* **Antrian prioritas** untuk menentukan dengan efisien simpul berikutnya yang belum dikunjungi dengan jarak terkecil. Antrian prioritas sangat penting untuk membuat algoritma cepat, karena memungkinkan pengambilan simpul dengan jarak minimum secara cepat.

### Algoritma Langkah-demi-Langkah 🗺️

Proses ini berlangsung sebagai berikut:

1. **Inisialisasi**: Tentukan jarak ke simpul sumber sebagai 0 dan semua simpul lainnya sebagai tak terhingga. Tambahkan simpul sumber ke dalam antrian prioritas.
2. **Loop**: Selama antrian prioritas tidak kosong, ambil simpul dengan jarak terkecil. Sebut saja simpul ini `u`.
3. **Kunjungi**: Jika `u` sudah dikunjungi, lewati simpul tersebut. Jika tidak, tandai `u` sebagai simpul yang telah dikunjungi.
4. **Relaksasi Sisi**: Untuk setiap tetangga `v` dari `u`, hitung jarak ke `v` melalui `u` (jarak ke `u` + berat sisi `u-v`). Jika jarak baru ini lebih pendek dari jarak yang diketahui ke `v`, perbarui jaraknya dan tambahkan `v` ke antrian prioritas dengan jarak yang baru dan lebih pendek.
   Proses ini berlanjut hingga semua simpul yang dapat dijangkau telah dikunjungi.

### Contoh Sederhana

Bayangkan sebuah graf di mana Anda ingin menemukan jalur terpendek dari simpul A ke simpul C. Misalkan ada jalur A → B (berat 1) dan B → C (berat 2), untuk total berat 3. Ada juga jalur langsung A → C (berat 5).

1. Algoritma Dijkstra dimulai di A (jarak 0).
2. Algoritma menjelajahi tetangga A. Ditemukan jalur ke B dengan biaya 1 dan jalur ke C dengan biaya 5.
3. Simpul berikutnya yang paling dekat adalah B (biaya 1), jadi algoritma pindah ke B.
4. Dari B, algoritma menjelajahi tetangganya dan menemukan jalur ke C dengan biaya (biaya ke B) + (biaya B→C) = 1 + 2 = 3.
5. Karena 3 lebih kecil dari biaya sebelumnya 5 untuk mencapai C, algoritma memperbarui jalur terpendek ke C menjadi 3.

### Pembatasan Penting: Berat Negatif

Salah satu keterbatasan utama dari Algoritma Dijkstra adalah bahwa algoritma ini **tidak bekerja dengan benar pada graf yang memiliki sisi berbobot negatif**. Karena sifat greedy dari algoritma ini, yang menganggap simpul yang sudah dikunjungi sebagai simpul dengan jarak terpendek, sebuah sisi negatif yang ditemukan kemudian dapat menciptakan jalur yang lebih pendek ke simpul yang sudah ditandai sebagai dikunjungi. Hal ini tidak dapat ditangani oleh Dijkstra. Untuk graf dengan sisi berbobot negatif, algoritma lain seperti Algoritma Bellman-Ford harus digunakan.

### Aplikasi Dunia Nyata 🌍

Algoritma Dijkstra adalah dasar dari teknologi dan logistik modern. Aplikasi paling terkenalnya adalah dalam **protokol routing jaringan**; perangkat GPS dan layanan pemetaan seperti Google Maps menggunakannya (atau variasinya seperti A\*) untuk menemukan rute tercepat antara dua lokasi. Algoritma ini juga digunakan dalam telekomunikasi untuk menemukan jalur optimal bagi paket data yang melintasi jaringan dan dalam jejaring sosial untuk menemukan derajat pemisahan terpendek antara dua orang.
