---

title: Tikus dalam Labirin
date: 2025-05-27
categories: \[desain dan analisis algoritma]
tags: \[belajar]     # TAG names should always be lowercase
description: Apa itu Masalah Tikus dalam Labirin?
-------------------------------------------------

### Apa Itu Masalah Tikus dalam Labirin?

Puzzle Tikus dalam Labirin adalah masalah pencarian jalur klasik yang sering digunakan sebagai pengantar untuk algoritma yang lebih kompleks dalam ilmu komputer. Bayangkan sebuah tikus yang ditempatkan di sudut kiri atas sebuah labirin berbentuk persegi yang terdiri dari berbagai sel. Tujuan tikus tersebut adalah untuk mencapai potongan keju yang terletak di sudut kanan bawah. Namun, labirin ini memiliki rintangan atau sel yang "terhalang" yang tidak dapat dilalui oleh tikus. Tantangannya adalah menemukan jalur yang jelas, yaitu urutan gerakan yang valid, dari titik awal menuju tujuan, sambil menghindari semua sel yang terhalang sepanjang perjalanan.

### Memformalkan Masalah

Secara komputasional, labirin ini direpresentasikan sebagai matriks biner dua dimensi. Biasanya, `1` mewakili sel terbuka tempat tikus bisa bergerak, dan `0` mewakili sel yang terhalang atau dinding. Posisi awal biasanya berada di sel kiri atas dengan indeks `[0][0]`, dan tujuan ada di sel kanan bawah dengan indeks `[N-1][N-1]`, di mana N adalah ukuran labirin. Aturan gerakan juga ditentukan; dalam versi paling sederhana dari masalah ini, tikus hanya dapat bergerak ke dua arah: maju (ke bawah) dan ke kanan. Outputnya adalah jalur, yang sering kali direpresentasikan dengan matriks lain dari ukuran yang sama yang menunjukkan sel-sel yang membentuk jalur solusi.

### Strategi Inti: Backtracking

Cara yang paling intuitif dan umum untuk menyelesaikan masalah Tikus dalam Labirin adalah dengan menggunakan **backtracking**. Backtracking adalah teknik algoritmik yang didasarkan pada percakapan dan kesalahan. Inti dari ide ini adalah menjelajahi sebuah jalur sejauh mungkin. Jika jalur tersebut mengarah ke jalan buntu atau sel yang terhalang, algoritma akan "kembali" atau mundur ke posisi sebelumnya dan mencoba arah alternatif. Metode ini secara sistematis menjelajahi semua kemungkinan rute dari titik awal sampai jalur yang valid menuju tujuan ditemukan.

### Algoritma Backtracking secara Detail

Algoritma ini bekerja secara rekursif. Algoritma dimulai dari sel awal `[0][0]` dan menandainya sebagai bagian dari jalur solusi. Dari sel saat ini, pertama-tama algoritma mencoba untuk bergerak ke satu arah (misalnya, ke bawah). Algoritma memeriksa apakah sel berikutnya validâ€”artinya, sel tersebut berada dalam batas labirin, bukan sel yang terhalang (adalah `1`), dan belum pernah dikunjungi dalam jalur saat ini. Jika gerakan tersebut valid, algoritma akan memanggil dirinya sendiri secara rekursif untuk sel baru tersebut. Jika panggilan rekursif ini akhirnya mengarah ke tujuan, maka akan mengembalikan nilai `true`. Jika tidak, ini berarti jalur yang dipilih merupakan jalan buntu. Algoritma kemudian **backtrack** dengan menghapus penandaan sel dari jalur solusi dan mencoba arah berikutnya yang mungkin (misalnya, kanan).

### Contoh Langkah-demi-Langkah

Misalkan tikus berada di sel `(r, c)`. Ia akan pertama kali mencoba bergerak ke bawah ke `(r+1, c)`. Jika gerakan ini valid, ia akan melanjutkan. Jika jalur dari `(r+1, c)` akhirnya mengarah ke jalan buntu, panggilan rekursif akan mengembalikan `false`. Algoritma kemudian mundur ke `(r, c)` dan mencoba gerakan berikutnya: ke kanan, ke `(r, c+1)`. Jika gerakan ini valid, algoritma akan menjelajahi jalur tersebut. Jika kedua gerakan, baik ke bawah maupun ke kanan dari `(r, c)`, mengarah ke jalan buntu, algoritma menyimpulkan bahwa tidak ada solusi dari `(r, c)` dan mundur lebih jauh dalam rantai pemanggilan. Proses ini terus berlanjut sampai jalur lengkap ditemukan atau semua kemungkinan telah habis.

### Variasi dan Perluasan

Masalah Tikus dalam Labirin yang dasar dapat diperluas untuk tantangan yang lebih besar. Misalnya, tikus dapat diizinkan untuk bergerak di keempat arah (atas, bawah, kiri, dan kanan). Variasi umum lainnya adalah untuk menemukan *semua* jalur yang mungkin dari awal ke tujuan, bukan hanya satu. Untuk melakukan ini, alih-alih berhenti setelah menemukan solusi pertama, algoritma akan mencetak jalur dan terus backtrack untuk mengeksplorasi rute lainnya. Selain itu, jika tujuan adalah untuk menemukan jalur *terpendek*, backtracking bukanlah metode yang paling efisien. Algoritma seperti **Breadth-First Search (BFS)** akan lebih cocok, karena mengeksplorasi labirin secara level per level, menjamin bahwa jalur pertama yang ditemukan menuju tujuan adalah jalur terpendek.

### Aplikasi Dunia Nyata

Meskipun terdengar seperti puzzle sederhana, prinsip-prinsip di balik penyelesaian masalah Tikus dalam Labirin sangat fundamental bagi banyak aplikasi dunia nyata. Algoritma pencarian jalur sangat penting dalam robotika untuk membantu robot menavigasi melalui gudang atau medan yang tidak dikenal. Ini adalah tulang punggung kecerdasan buatan dalam video game, memungkinkan karakter non-pemain bergerak di sekitar lingkungan yang kompleks. Konsep ini juga diterapkan dalam pengaturan routing jaringan untuk menemukan jalur yang efisien bagi paket data untuk berjalan dari sumber ke tujuan, dan bahkan dalam merancang solusi untuk labirin fisik atau logistik transportasi.
